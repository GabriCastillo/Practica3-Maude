view Int from TRIV to INT is
	sort Elt to Int .
endv

view Bool from TRIV to BOOL is
	sort Elt to Bool .
endv


fmod MEMORY is
    pr INT .
    pr BOOL .
  
    sorts Memory IntVar BoolVar .
    op none : -> Memory .
    op __ : Memory Memory -> Memory [assoc comm id: none] .
    op [_,_] : IntVar Int -> Memory .
    op [_,_] : BoolVar Bool -> Memory .

    op _in_ : IntVar Memory -> Bool .
    op _in_ : BoolVar Memory -> Bool .
    var Q  W : IntVar .
    var Q' Z : BoolVar .
    var M : Memory .
    var N E I : Int .
    var N' E' B : Bool .
 

    eq Q in [Q, N] M = true .
    eq Q in [W, N] M = Q in M .
    eq Q in none = false .

    eq Q' in [Q', N'] M = true .
    eq Q' in [Z, N'] M = Q' in M .
    eq Q' in none = false .


    
endfm


fmod EXPRESSION is
    including MEMORY .

    sort Test .

    sort BExpression .
    subsorts BoolVar Bool < BExpression .

    sort IExpression .
    subsorts IntVar Int < IExpression .

    var V' : IntVar .
    vars I I' : Int .
    vars IE IE’ : IExpression .


    var V : BoolVar .
    var M : Memory .
    vars B B' : Bool .
    vars E E’ : BExpression .

    op _=_ : BoolVar Bool -> Test .
    op _!=_ : BoolVar Bool -> Test .
    op eval : Test Memory -> Bool .

    op _=_ : IntVar Int -> Test .
    op _>’_ : IntVar Int -> Test .
    op _!=_ : IntVar Int -> Test .

    eq eval(V = B, [V, B'] M) = B == B' .
    ceq eval(V = B, M) = B == false if V in M =/= true .
    eq eval(V != B, M) = not eval(V = B, M) .

    op _&_ : BExpression BExpression -> BExpression [comm assoc] .
    op eval : BExpression Memory -> Bool .

    eq eval(B, M) = B .
    eq eval(V, [V, B] M) = B .
    eq eval(V, M) = false [owise] .

    eq eval(E & E’, M) = eval(E, M) and eval(E’, M) .



    eq eval(V' = I, [V', I'] M) = I == I' .
    ceq eval(V' = I, M) = I == 0 if V' in M =/= true .
    eq eval(V' >’ I, [V', I'] M) = I' > I .
    eq eval(V' >’ I, M) = 0 > I [owise] .
    eq eval(V' != I, M) = eval(V' = I, M) =/= true .

    op _+’_ : IExpression IExpression -> IExpression [ctor] .
    op _*’_ : IExpression IExpression -> IExpression [ctor] .
    op _-’_ : IExpression IExpression -> IExpression [ctor] .
    op eval : IExpression Memory -> Int .

    eq eval(I, M) = I .
    eq eval(V', [V', I] M) = I .
    eq eval(V', M) = 0 [owise] .

    eq eval(IE +’ IE’, M) = eval(IE, M) + eval(IE’, M) .
    eq eval(IE *’ IE’, M) = eval(IE, M) * eval(IE’, M) .
    eq eval(IE -’ IE’, M) = eval(IE, M) - eval(IE’, M) .

endfm

fmod ARRAYS is 
    pr EXPRESSION .
    pr INT .
    pr BOOL .
    pr LIST{Int} .
    pr LIST{Bool} .

    subsort Int < List{Int} .
    subsort Bool < List{Bool} .
    subsort List{Bool} < BExpression .
    subsort List{Int}  < IExpression .


    op Inil : -> List{Int} [ctor] .
    op Bnil : -> List{Bool} [ctor] .

    op _[_] :  IntVar IExpression -> List{Int} .
    op _[_] :  BoolVar IExpression -> List{Bool} .

    op _[_] :=_ : IntVar IExpression IExpression -> List{Int} .
    op _[_] :=_ : BoolVar IExpression BExpression -> List{Bool} .
    
    op [_,_] : IntVar List{Int} -> Memory .
    op [_,_] : BoolVar List{Bool} -> Memory .


    var li : List{Int} .
    var lb : List{Bool} .
    var N E I : Int .
    var N' E' B : Bool .

    

endfm

fmod SEQUENTIAL is
    protecting ARRAYS .

    sorts UserStatement LoopingUserStatement Program .
    subsort LoopingUserStatement < UserStatement < Program .

    op skip : -> Program .
    op _;_ : Program Program -> Program [prec 61 assoc id: skip] .
    op _:=_ : BoolVar BExpression -> Program .
    op _:=_ : IntVar IExpression -> Program .
    op _:=_ : List{Bool} BExpression -> Program .
    op _:=_ : List{Int} IExpression -> Program .

    op if_then_fi : Test Program -> Program .
    op while_do_od : Test Program -> Program .
    op repeat_forever : Program -> Program .
    op if_then_else_fi : Test Program Program -> Program . 
    op repeat_until_li : Program Test -> Program .


    var M : Memory .
    var Q' : BoolVar .
    var Q : IntVar .
    var B : List{Bool} .
    var X : List{Int} .
    var N : IExpression .
    
    eq eval(Q'[N], [Q', B] M) = B[N] .
    eq eval(Q[N], [Q, X] M) = X[N] .

endfm


mod PARALLEL++ is
    protecting SEQUENTIAL .
   

    sorts Pid Process Soup MachineState  .
    subsort Process < Soup .
    subsort Int < Pid .


    op [_,_] : Pid Program -> Process .
    op empty : -> Soup .
    op _|_ : Soup Soup -> Soup [prec 61 assoc comm id: empty] .
    op {_,_} : Soup Memory -> MachineState . 

    vars P R W : Program . 
    var S : Soup .
    var U : UserStatement . 
    var L : LoopingUserStatement .
    vars I J : Pid . 
    var M : Memory .
    var Q : IntVar . 
    var Q' : BoolVar . 
    var X : Int .
    var A : Bool .
    var T : Test . 
    vars IE IE' : IExpression .
    var BE : BExpression .
    var B : List{Bool} .
 

    rl {[I, L ; R] | S, M} => {[I, L ; R] | S, M} .

    rl {[I, U ; R] | S, M} => {[I, R] | S, M} .

    rl {[I, (Q := IE) ; R] | S, [Q, X] M} => {[I, R] | S, [Q, eval(IE, [Q, X] M)] M} .
    rl {[I, (Q' := BE) ; R] | S, [Q', A] M} => {[I, R] | S, [Q', eval(BE, [Q', A] M)] M} .


    crl {[I, (Q := IE) ; R] | S, M} => {[I, R] | S, [Q, eval(IE, M)] M} 
    if Q in M =/= true .

    crl {[I, (Q' := BE) ; R] | S, M} => {[I, R] | S, [Q', eval(BE, M)] M} 
    if Q' in M =/= true .

    rl {[I, if T then P fi ; R] | S, M}  => {[I, if eval(T, M) then P else skip fi ; R] | S, M} .
    rl {[I, if T then P fi ; R] | S, M}  => {[I, if eval(T, M) then P else skip fi ; R] | S, M} .

   
    rl {[I, if T then P else W fi ; R] | S, M}  => {[I, if eval(T, M) then P else W fi ; R] | S, M}  .   

    rl {[I, repeat P until T li ; R] | S, M}  => {[I, (P ; if eval(T,M) then skip else (repeat P until T li) fi ; R)] | S, M} .
    

    rl {[I, while T do P od ; R] | S, M}  => {[I, if eval(T, M) then (P ; while T do P od) else skip fi ; R] | S, M} .

    rl {[I, repeat P forever ; R] | S, M} => {[I, P ; repeat P forever ; R] | S, M} .

    --- ARRAY OF BOOLEANS
    --- Array exists, insert
    rl [BArrayInsert] : {[I, (Q'[IE] := BE) ; R] | S, [Q', A] M} => {[I, R] | S, 
    [Q' , A

     eval(BE, [Q', A] M) --- eval(BE, [Q', A] M) 
    
    ] M} .


    --- Array does not exist, initialize
    crl [BArrayCreate] : {[I, (Q'[IE] := BE) ; R] | S, M} => {[I, R] | S, 
    [Q', Bnil
    
      eval(BE, M) --- eval(IE, M)
    
    ] M} 
    if Q' in M == false .

    --- ARRAY OF INTEGERS
    rl [IArrayInsert] : {[I, (Q[IE] := IE') ; R] | S, [Q, X] M}  => {[I, R] | S, [Q, (X eval(IE, [Q, X] M) eval(IE', [Q, X] M))] M} .


    crl [IArrayCreate] : {[I, (Q[IE] := IE') ; R] | S, M}  => {[I, R] | S, [Q, (Inil eval(IE, M) eval(IE', M))] M} 
    if Q in M == false .

endm



