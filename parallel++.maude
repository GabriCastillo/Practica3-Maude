fmod MEMORY is
    pr INT .
    pr BOOL .
    sorts Memory IntVar BoolVar .
    op none : -> Memory .
    op __ : Memory Memory -> Memory [assoc comm id: none] .
    op [_,_] : IntVar Int -> Memory .
    op [_,_] : BoolVar Bool -> Memory .

    op _in_ : IntVar Memory -> Bool .
    op _in_ : BoolVar Memory -> Bool .
    var Q  W : IntVar .
    var Q' Z : BoolVar .
    var M : Memory .
    var N : Int .
    var N' : Bool .

    eq Q in [Q, N] M = true .
    eq Q in [W, N] M = Q in M .
    eq Q in none = false .

    eq Q' in [Q', N'] M = true .
    eq Q' in [Z, N'] M = Q' in M .
    eq Q' in none = false .
endfm

fmod EXPRESSION is
    including MEMORY .

    sort BExpression BTest .
    subsorts BoolVar Bool < BExpression .

    sort IExpression ITest .
    subsorts IntVar Int < IExpression .

    var V' : IntVar .
    vars I I' : Int .
    vars IE IE’ : IExpression .


    var V : BoolVar .
    var M : Memory .
    vars B B' : Bool .
    vars E E’ : BExpression .

    op _=_ : BoolVar Bool -> BTest .
    op _!=_ : BoolVar Bool -> BTest .
    op eval : BTest Memory -> Bool .

    op _=_ : IntVar Int -> ITest .
    op _>’_ : IntVar Int -> ITest .
    op _!=_ : IntVar Int -> ITest .
    op eval : ITest Memory -> Bool .

    eq eval(V = B, [V, B'] M) = B == B' .
    ceq eval(V = B, M) = B == false if V in M =/= true .
    eq eval(V != B, M) = not eval(V = B, M) .

    op _&_ : BExpression BExpression -> BExpression [comm assoc] .
    op eval : BExpression Memory -> Bool .

    eq eval(B, M) = B .
    eq eval(V, [V, B] M) = B .
    eq eval(V, M) = false [owise] .

    eq eval(E & E’, M) = eval(E, M) and eval(E’, M) .



    eq eval(V' = I, [V', I'] M) = I == I' .
    ceq eval(V' = I, M) = I == 0 if V' in M =/= true .
    eq eval(V' >’ I, [V', I'] M) = I' > I .
    eq eval(V' >’ I, M) = 0 > I [owise] .
    eq eval(V' != I, M) = eval(V' = I, M) =/= true .

    op _+’_ : IExpression IExpression -> IExpression [ctor] .
    op _*’_ : IExpression IExpression -> IExpression [ctor] .
    op _-’_ : IExpression IExpression -> IExpression [ctor] .
    op eval : IExpression Memory -> Int .

    eq eval(I, M) = I .
    eq eval(V', [V', I] M) = I .
    eq eval(V', M) = 0 [owise] .

    eq eval(IE +’ IE’, M) = eval(IE, M) + eval(IE’, M) .
    eq eval(IE *’ IE’, M) = eval(IE, M) * eval(IE’, M) .
    eq eval(IE -’ IE’, M) = eval(IE, M) - eval(IE’, M) .




endfm

fmod SEQUENTIAL is
    protecting EXPRESSION .

    sorts UserStatement LoopingUserStatement Program .
    subsort LoopingUserStatement < UserStatement < Program .

    op skip : -> Program .
    op _;_ : Program Program -> Program [prec 61 assoc id: skip] .
    op _:=_ : BoolVar BExpression -> Program .
    op _:=_ : IntVar IExpression -> Program .
    op if_then_fi : BTest Program -> Program .
    op while_do_od : BTest Program -> Program .
    op repeat_forever : Program -> Program .
    op if_then_else_fi : BTest Program Program -> Program . 
    op repeat_until_li : Program BTest -> Program .
endfm


mod PARALLEL++ is
    protecting SEQUENTIAL .
   

    sorts Pid Process Soup MachineState  .
    subsort Process < Soup .
    subsort Int < Pid .

    op [_,_] : Pid Program -> Process .
    op empty : -> Soup .
    op _|_ : Soup Soup -> Soup [prec 61 assoc comm id: empty] .
    op {_,_} : Soup Memory -> MachineState .

    vars P R : Program . 
    var  S : Soup .
    var  U : UserStatement . 
    var  L : LoopingUserStatement .
    vars I J : Pid . 
    var  M : Memory .
    var  Q : IntVar . 
    var  Q' : BoolVar . 
    var  X : Int .
    var  A : Bool .
    var  T : ITest . 
    var  T' : BTest .
    var  IE : IExpression .
    var  BE : BExpression .

    rl {[I, L ; R] | S, M} => {[I, L ; R] | S, M} .

    rl {[I, U ; R] | S, M} => {[I, R] | S, M} .

    rl {[I, (Q := IE) ; R] | S, [Q, X] M} => {[I, R] | S, [Q, eval(IE, [Q, X] M)] M} .
    ---rl {[I, (Q' := BE) ; R] | S, [Q', X] M} => {[I, R] | S, [Q', eval(BE, [Q', X] M)] M} .


    crl {[I, (Q := IE) ; R] | S, M} => {[I, R] | S, [Q, eval(IE, M)] M} if Q in M =/= true .
    crl {[I, (Q' := BE) ; R] | S, M} => {[I, R] | S, [Q', eval(BE, M)] M} if Q' in M =/= true .

  ---  rl {[I, if T then P fi ; R] | S, M}  => {[I, if eval(T, M) then P else skip fi ; R] | S, M} .
    rl {[I, if T' then P fi ; R] | S, M}  => {[I, if eval(T', M) then P else skip fi ; R] | S, M} .


  ---  rl {[I, while T do P od ; R] | S, M}  => {[I, if eval(T, M) then (P ; while T do P od) else skip fi ; R] | S, M} .
    rl {[I, while T' do P od ; R] | S, M}  => {[I, if eval(T', M) then (P ; while T' do P od) else skip fi ; R] | S, M} .

    rl {[I, repeat P forever ; R] | S, M} => {[I, P ; repeat P forever ; R] | S, M} .
      
endm



