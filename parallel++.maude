fmod VARIABLE is
   sorts IntVar BoolVar Var .
   subsort IntVar BoolVar < Var .
endfm

fmod MEMORY{Val :: TRIV} is
    extending VARIABLE .
    sorts Memory .
    op none : -> Memory .
    op __ : Memory Memory -> Memory [assoc comm id: none] .
    op [_,_] : Var Val$Elt -> Memory .
    op _in_ : Var Memory -> Bool .
    var Q  Q' : Var .
    var M : Memory .
    var N : Val$Elt .
    eq Q in [Q, N] M = true .
    eq Q in [Q', N] M = Q in M .
    eq Q in none = false .
endfm

view IntVal from TRIV to INT is
	sort Elt to Int .
endv

view BoolVal from TRIV to BOOL is
	sort Elt to Bool .
endv

fmod EXPRESSION-BOOL is
    including MEMORY{BoolVal} * (sort Memory to BMemory) .

    sort BExpression BTest .
    subsorts BoolVar Bool < BExpression .

    var V : BoolVar .
    var M : BMemory .
    vars B B' : Bool .
    vars E E’ : BExpression .

    op _=_ : BoolVar Bool -> BTest .
    op _!=_ : BoolVar Bool -> BTest .
    op eval : BTest BMemory -> Bool .

    eq eval(V = B, [V, B'] M) = B == B' .
    ceq eval(V = B, M) = B == false if V in M =/= true .
    eq eval(V != B, M) = not eval(V = B, M) .

    op _&_ : BExpression BExpression -> BExpression [comm assoc] .
    op eval : BExpression BMemory -> Bool .

    eq eval(B, M) = B .
    eq eval(V, [V, B] M) = B .
    eq eval(V, M) = false [owise] .

    eq eval(E & E’, M) = eval(E, M) and eval(E’, M) .
endfm

fmod EXPRESSION-INT is
    including MEMORY{IntVal} * (sort Memory to IMemory) .

    sort IExpression ITest .
    subsorts IntVar Int < IExpression .

    var V : IntVar .
    var M : IMemory .
    vars N N' : Int .
    vars E E’ : IExpression .

    op _=_ : IntVar Int -> ITest .
    op _>’_ : IntVar Int -> ITest .
    op _!=_ : IntVar Int -> ITest .
    op eval : ITest IMemory -> Bool .

    eq eval(V = N, [V, N'] M) = N == N' .
    ceq eval(V = N, M) = N == 0 if V in M =/= true .
    eq eval(V >’ N, [V, N'] M) = N' > N .
    eq eval(V >’ N, M) = 0 > N [owise] .
    eq eval(V != N, M) = eval(V = N, M) =/= true .

    op _+’_ : IExpression IExpression -> IExpression [ctor] .
    op _*’_ : IExpression IExpression -> IExpression [ctor] .
    op _-’_ : IExpression IExpression -> IExpression [ctor] .
    op eval : IExpression IMemory -> Int .

    eq eval(N, M) = N .
    eq eval(V, [V, N] M) = N .
    eq eval(V, M) = 0 [owise] .

    eq eval(E +’ E’, M) = eval(E, M) + eval(E’, M) .
    eq eval(E *’ E’, M) = eval(E, M) * eval(E’, M) .
    eq eval(E -’ E’, M) = eval(E, M) - eval(E’, M) .
endfm

fmod SEQUENTIAL is
    protecting EXPRESSION-BOOL .
    protecting EXPRESSION-INT .

    sorts UserStatement LoopingUserStatement Program .
    subsort LoopingUserStatement < UserStatement < Program .

    op skip : -> Program .
    op _;_ : Program Program -> Program [prec 61 assoc id: skip] .
    op _:=_ : BoolVar BExpression -> Program .
    op _:=_ : IntVar IExpression -> Program .
    op if_then_fi : BTest Program -> Program .
    op while_do_od : BTest Program -> Program .
    op repeat_forever : Program -> Program .
    op if_then_else_fi : BTest Program Program -> Program . 
    op repeat_until_li : Program BTest -> Program .
endfm

---(
mod PARALLEL++ is
    inc SEQUENTIAL .

    sorts Pid Process Soup MachineState .
    subsort Process < Soup .
    subsort Int < Pid .

    op [_,_] : Pid Program -> Process .
    op empty : -> Soup .
    op _|_ : Soup Soup -> Soup [prec 61 assoc comm id: empty] .
    op {_,_} : Soup Memory -> MachineState .

    vars P R : Program . 
    var  S : Soup .
    var  U : UserStatement . 
    var  L : LoopingUserStatement .
    vars I J : Pid . 
    var  M : Memory .
    var  Q : IntVar . 
    vars N X : Int .
    var  T : Test . 
    var  E : Expression .

    rl {[I, L ; R] | S, M} => {[I, L ; R] | S, M} .
    rl {[I, U ; R] | S, M} => {[I, R] | S, M} .
    rl {[I, (Q := E) ; R] | S, [Q, X] M} 
      => {[I, R] | S, [Q, eval(E, [Q, X] M)] M} .
   crl {[I, (Q := E) ; R] | S, M} 
      => {[I, R] | S, [Q, eval(E, M)] M} 
      if Q in M =/= true .
    rl {[I, if T then P fi ; R] | S, M} 
      => {[I, if eval(T, M) then P else skip fi ; R] | S, M} .
    rl {[I, while T do P od ; R] | S, M} 
      => {[I, if eval(T, M) 
              then (P ; while T do P od) 
              else skip 
              fi ; R] | S, M} .
    rl {[I, repeat P forever ; R] | S, M} 
      => {[I, P ; repeat P forever ; R] | S, M} .
endm
)---



