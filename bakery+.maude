load bakery.maude

mod BAKERY+ is
	including BAKERY .
	protecting BOOL .

	vars N M T : Nat .
	var S : Mode .
	var C : Configuration .
	
	op droppedTicket : Configuration Nat -> Bool .

	eq droppedTicket(none, T) = true .
	ceq droppedTicket(< O : Dispenser | next: N, last: M > C, T) 
		= droppedTicket(C, T) 
		if C =/= none .
	ceq droppedTicket(< N : BProcess | mode: S, number: M > C, T) 
	= if M == T then false else droppedTicket(C, T) fi 
	if C =/= none .

	crl [drop_ticket] : 
		[[ < N : BProcess | mode: wait, number: M > C ]] 
		=> 
		[[ < N : BProcess | mode: sleep, number: 0 > C ]] 
		if M =/= 0 .
	crl [next_ticket] : 
		[[ < O : Dispenser | next: N, last: M > C ]] 
		=> 
		[[ < O : Dispenser | next: s(N), last: M > C ]] 
		if droppedTicket(C, N) . 
endm

mod ABSTRACT-BAKERY+ is 
	including NAT .
	including INT .
	including BAKERY+ .

	var M : Mode . 
	vars N N' X : Nat .
	vars C C' : Configuration .

	op inf : -> Nat [ctor] .
	
	op minf : Nat Nat -> Nat [comm assoc] .
	eq minf(N, inf) = N .
	eq minf(N,N') = min(N,N') .

	op minTicket : Configuration -> Nat .
	eq minTicket(none) = inf .
	eq minTicket(< O : Dispenser | next: N, last: N' >) = inf .
	eq minTicket(< N : BProcess | mode: M, number: 0 >) = inf .
	ceq minTicket(< N : BProcess | mode: M, number: N' >) = N' 
		if N' > 0  .
	ceq minTicket(C C') = minf(minTicket(C), minTicket(C')) 
		if C =/= none /\ C' =/= none .

	op maxTicket : Configuration -> Nat .
	eq maxTicket(none) = 0 .
	eq maxTicket(< O : Dispenser | next: N, last: N' >) = 0 .
	eq maxTicket(< N : BProcess | mode: M, number: N' >) = N' .
	ceq maxTicket(C C') = max(maxTicket(C), maxTicket(C')) 
		if C =/= none /\ C' =/= none .

	op numTickets : Configuration -> Nat .
	eq numTickets(none) = 0 .
	eq numTickets(< X : BProcess | mode: wait, number: N >) = 1 .
	eq numTickets(< O : Dispenser | next: N, last: N' >) = 0 .
	ceq numTickets(< X : BProcess | mode: M, number: N >) = 0 
		if M =/= wait .
	ceq numTickets(C C') = numTickets(C) + numTickets(C') 
		if C =/= none /\ C' =/= none .

	op isCrit : Configuration -> Bool .
    eq isCrit(none) = false .
    eq isCrit(< O : Dispenser | next: N, last: N' >) = false .
    eq isCrit(< X : BProcess | mode: crit, number: N >) = true .
    ceq isCrit(< X : BProcess | mode: M, number: N >) = false 
        if M =/= crit .
    ceq isCrit(C C') = isCrit(C) or isCrit(C')
        if C =/= none /\ C' =/= none .

	op collapse : Configuration Nat Nat -> Configuration .
	eq collapse(none, N, N') = none .
	eq collapse(< X : BProcess | mode: M, number: 0 > C, N, N') 
		= < X : BProcess | mode: M, number: 0 >
		collapse(C, minTicket(C), N') .
	ceq collapse(< X : BProcess | mode: M, number: N > C, N, N') 
		= < X : BProcess | mode: M, number: N' > 
		collapse(C, minTicket(C), s(N')) 
		if N > 0 .

	ceq [[< O : Dispenser | next: N, last: N' > C ]]
		= [[< O : Dispenser | next: minTicket(C'), last: maxTicket(C') > C' ]] 
		if isCrit(C) 
		/\ minTicket(C) =/= inf
		/\ C' := collapse(C, minTicket(C), 2)
		/\ ((maxTicket(C) - minTicket(C)) + 1 > numTickets(C) 
			or minTicket(C) > 1) .

	ceq [[< O : Dispenser | next: N, last: N' > C ]]
		= [[< O : Dispenser | next: minTicket(C'), last: maxTicket(C') > C' ]] 
		if not isCrit(C) 
		/\ minTicket(C) =/= inf
		/\ C' := collapse(C, minTicket(C), 1)
		/\ ((maxTicket(C) - minTicket(C)) + 1 > numTickets(C) 
			or minTicket(C) > 1) .

endm