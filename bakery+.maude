load bakery.maude

mod BAKERY+ is
	including BAKERY .
	protecting BOOL .

	vars N M T : Nat .
	var S : Mode .
	var C : Configuration .
	
	op droppedTicket : Configuration Nat -> Bool .

	eq droppedTicket(none, T) = true .
	ceq droppedTicket(< O : Dispenser | next: N, last: M > C, T) 
		= droppedTicket(C, T) 
		if C =/= none .
	ceq droppedTicket(< N : BProcess | mode: S, number: M > C, T) 
	= if M == T then false else droppedTicket(C, T) fi 
	if C =/= none .

	crl [drop_ticket] : 
		[[ < N : BProcess | mode: wait, number: M > C ]] 
		=> 
		[[ < N : BProcess | mode: sleep, number: 0 > C ]] 
		if M =/= 0 .
	crl [next_ticket] : 
		[[ < O : Dispenser | next: N, last: M > C ]] 
		=> 
		[[ < O : Dispenser | next: s(N), last: M > C ]] 
		if droppedTicket(C, N) . 
endm

mod ABSTRACT-BAKERY+ is 
	including NAT .
	including INT .
	including BAKERY+ .

	var M : Mode . 
	vars N N' X : Nat .
	vars C C' : Configuration .

	op inf : -> Nat [ctor] .
	
	op minf : Nat Nat -> Nat [comm assoc] .
	eq minf(N, inf) = N .
	eq minf(N,N') = min(N,N') .

	op minTicket : Configuration -> Nat .
	eq minTicket(none) = inf .
	eq minTicket(< O : Dispenser | next: N, last: N' >) = inf .
	eq minTicket(< N : BProcess | mode: wait, number: N' >) = N' .
	ceq minTicket(< N : BProcess | mode: M, number: N' >) = inf 
		if M =/= wait  .
	ceq minTicket(C C') = minf(minTicket(C), minTicket(C')) 
		if C =/= none /\ C' =/= none .

	op maxTicket : Configuration -> Nat .
	eq maxTicket(none) = 0 .
	eq maxTicket(< O : Dispenser | next: N, last: N' >) = 0 .
	eq maxTicket(< N : BProcess | mode: wait, number: N' >) = N' .
	ceq maxTicket(< N : BProcess | mode: M, number: N' >) = 0 
		if M =/= wait .
	ceq maxTicket(C C') = max(maxTicket(C), maxTicket(C')) 
		if C =/= none /\ C' =/= none .

	op numTickets : Configuration -> Nat .
	eq numTickets(none) = 0 .
	eq numTickets(< X : BProcess | mode: wait, number: N >) = 1 .
	eq numTickets(< O : Dispenser | next: N, last: N' >) = 0 .
	ceq numTickets(< X : BProcess | mode: M, number: N >) = 0 
		if M =/= wait .
	ceq numTickets(C C') = numTickets(C) + numTickets(C') 
		if C =/= none /\ C' =/= none .

	op isCrit : Configuration -> Bool .
	eq isCrit(none) = true .
	eq isCrit(< O : Dispenser | next: N, last: N' >) = true .
	eq isCrit(< X : BProcess | mode: crit, number: N >) = false .
	ceq isCrit(< X : BProcess | mode: M, number: N >) = true 
		if M =/= crit .
	ceq isCrit(C C') = isCrit(C) and isCrit(C')
		if C =/= none /\ C' =/= none .

	op collapse : Configuration Nat Nat -> Configuration .
	eq collapse(none, N, N') = none .
	eq collapse(< X : BProcess | mode: M, number: 0 > C, N, N') 
		= < X : BProcess | mode: M, number: 0 >
		collapse(C, minTicket(C), N') .
	ceq collapse(< X : BProcess | mode: M, number: N > C, N, N') 
		= < X : BProcess | mode: M, number: N' > 
		collapse(C, minTicket(C), s(N')) 
		if N > 0 .

	ceq [[< O : Dispenser | next: N, last: N' > C ]]
		= if isCrit(C) 
		then [[< O : Dispenser | next: minTicket(C'), last: maxTicket(C') > collapse(C, minTicket(C), 2 ) ]]
		else [[< O : Dispenser | next: minTicket(C'), last: maxTicket(C') > collapse(C, minTicket(C), 1 ) ]]
		fi
		if minTicket(C) =/= inf
		/\ C' := collapse(C, minTicket(C), 1)
		/\ ((maxTicket(C) - minTicket(C)) + 1 > numTickets(C) 
			or minTicket(C) > 1) .
endm